#!/usr/bin/env lua
-- <!-- vim : set ts=4 sts=4 et : -->
-- <img src=tree.png align=left width=500>
local l,the={},{}
local help=[[
# tree.lua 
Multi-objective tree generation   
(c)2024 Tim Menzies <timm@ieee.org> MIT license

## INSTALL
wget https://raw.githubusercontent.com/timm/ezr/main/src/tree.lua

## USAGE 
lua sandbox.lua [OPTIONS] [ACTIONS]

## OPTIONS
      -b --bins   number of bins (before merging) = 17
      -c --cohen  less than cohen*sd means "same" = 0.35
      -f --fmt    format string for number        = %g
      -h --help   show help                       = false
      -s --seed   random number seed              = 1234567891
      -t --train  training data                   = ../data/misc/auto93.csv
      actions     list available start up actions

The tree generated by this code reports a how to select for rows
of different value. The left-ish branch of that tree points to the
better rows. ]]

local l=require"lib"
local the=require"config"
local discrete = require"discretize"
local NUM,SYM,DATA,BIN = discrete.NUM, discrete.SYM, discrete.DATA, discrete.BIN
local TREE={}
------------------------------------------------------------------------------
-- ## Inference Layer

-- ### Tree
-- -- rebin at each lelvel. keep in the same data. pass arund rows. gen a new data in each row.
function TREE.new(here,lvl,name,pos,lo,hi,mu)
  return l.new(TREE,{lvl=lvl or 0, bin=BIN.new(name,pos,lo,hi), 
                     mu=mu or 0 , here=here, _kids={}})  end

function TREE:__tostring() 
  return l.fmt("%.2f\t%5s\t%s%s", self.mu, #self.here.rows, 
                                  ("|.. "):rep(self.lvl-1), self.lvl==0 and "" or self.bin) end

function TREE:visit(fun) 
  fun = fun or print
  fun(self)
  for _,kid in pairs(self._kids) do kid:visit(fun) end end 
------------------------------------------------------------------------------
-- Make tree
function DATA:tree(  stop,_grow)
  function _grow(rows,stop,lvl,  name,pos,lo,hi,    tree,tbins,sub,c)
    tree = TREE.new(self:clone(rows), lvl,name,pos,lo,hi,self:chebyshevs(rows).mu)
	  tbins = self:bins(rows)
    c={}
	  for pos,bin in pairs(l.sort(tbins[ self:argMin(tbins,rows,c) ],
                                function(a,b) return c[a._id] < c[b._id] end)) do 
	    sub = bin:selects(rows)
	    if #sub < #rows and #sub > stop then
	      l.push(tree._kids, _grow(sub,stop,lvl+1,
	                                 bin.name, bin.pos, bin.lo, bin.hi)) end end
	  return tree 
  end 
  return _grow(self.rows, (#self.rows)^.5, 0) end 

function DATA:argMin(tbins,rows, c,   lo,ns,sds,tmp,n,out)
  lo = l.inf
  for pos,bins in pairs(tbins) do
    out = out or pos
    ns,sds = 0,0
    for _,bin in pairs(bins) do 
       n=bin.y.n; ns = ns + n; sds = n*bin.y.sd 
       c[bin._id] = self:chebyshevs(bin:selects(rows)).mu
    end
    tmp = sds/ns 
    if tmp < lo then lo,out = tmp,pos end end
  return out end
--
-- ------------------------------------------------------------------------------
-- -- ## Lib
--
-- -- ### Object creation
-- local _id = 0
-- local function id() _id = _id + 1; return _id end
--
-- -- `new(klass: klass, t: dict) -> dict`      
-- -- Add a unique `id`; connection `t` to its `klass`; ensure `klass` knows to call itself.
-- function l.new (klass,t) 
--   t._id=id(); klass.__index=klass; setmetatable(t,klass); return t end
--
-- -- ### Lists
-- -- `push(t: list, x:any) -> x`
-- function l.push(t,x) t[1+#t]=x; return x end 
--
-- -- `sort(t: list, ?fun:callable) -> list`
-- function l.sort(t,  fun) table.sort(t,fun); return t end
--
-- function l.xby(x) 
--   return type(x)=="function" and function(a,b) return x(a) < x(b) end 
--                              or  function(a,b) print(4,x,l.o(a)); return a[x] < b[x] end end 
--
-- -- `copy(t: any) -> any`
-- function l.copy(t,     u)
--   if type(t) ~= "table" then return t end 
--   u={}; for k,v in pairs(t) do u[l.copy(k)] = l.copy(v) end 
--   return setmetatable(u, getmetatable(t)) end
--
-- -- ### Thing to string
-- l.fmt = string.format
--
-- -- `oo(x:any) : x`   
-- -- Show `x`, then return it.
-- function l.oo(x) print(l.o(x)); return x end
--
-- -- `o(x:any) : str`   
-- -- Generate a show string for `x`.
-- function l.o(x)
--   if type(x)=="number" then return l.fmt(the.fmt or "%g",x) end
--   if type(x)~="table"  then return tostring(x) end 
--   return "{" .. table.concat(#x==0 and l.okeys(x) or l.olist(x),", ")  .. "}" end
--
-- -- `olist(t:list) : str`   
-- -- Generate a show string for tables with numeric indexes.
-- function l.olist(t)  
--   local u={}; for k,v in pairs(t) do l.push(u, l.fmt("%s", l.o(v))) end; return u end
--
-- -- `okeys(t:dict) : str`   
-- -- Generate a show string for tables with symboloc indexes. Skip private keys; i.e.
-- -- those starting with "_".
-- function l.okeys(t)  
--   local u={} 
--   for k,v in pairs(t) do 
--     if not tostring(k):find"^_" then l.push(u, l.fmt(":%s %s", k,l.o(v))) end end; 
--   return l.sort(u) end
--
-- -- ### Strings to things
--
-- -- `coerce(s:str) : thing`    
-- function l.coerce(s,    also)
--   if type(s) ~= "string" then return s end
--   also = function(s) return s=="true" or s ~="false" and s end 
--   return math.tointeger(s) or tonumber(s) or also(s:match"^%s*(.-)%s*$") end 
--
-- -- `coerces(s:str) : list[thing]`
-- -- Coerce everything inside a comma-seperated string.
-- function l.coerces(s,    t)
--   t={}; for s1 in s:gsub("%s+", ""):gmatch("([^,]+)") do t[1+#t]=l.coerce(s1) end
--   return t end
--
-- -- Iterator `csv(file:str) : list[thing]`
-- function l.csv(file)
--   file = file=="-" and io.stdin or io.input(file)
--   return function(      s)
--     s = io.read()
--     if s then return l.coerces(s) else io.close(file) end end end
--
-- -- `settings(s:tr) : dict`  
-- -- For any line containing `--(key) ... = value`, generate `key=coerce(value)` .
-- function l.settings(s,     t)
--   t={}
--   for k,s1 in s:gmatch("[-][-]([%S]+)[^=]+=[%s]*([%S]+)[.]*\n") do t[k] = l.coerce(s1) end
--   return t end
--
------------------------------------------------------------------------------
-- ## Start-up Actions
local eg={}
local copy,o,oo,push=l.copy,l.o,l.oo,l.oush

eg["-h"] = function(x) print("lua tree.lua --tree file.csv") end

eg["-b"] = function(x) the.bins=  x end
eg["-c"] = function(x) the.cohen= x end
eg["-f"] = function(x) the.fmt=   x end
eg["-s"] = function(x) the.seed=  x end
eg["-t"] = function(x) the.train= x end

eg["--bins"] = function(file,     d) 
  d= DATA.new():import(file or the.train):sort()
  print(l.fmt("%.3f", d:chebyshevs().mu))
  for col,bins in pairs(d:bins(d.rows)) do
    print""
    for _,bin in pairs(bins) do
      print(l.fmt("%5.3g\t%3s\t%s", bin.y.mu, bin.y.n, bin)) end end  end

eg["--tree"] = function(file,     d,ys) 
  print(("-"):rep(40))
  eg["--bins"](file)
  print(("-"):rep(5))
  d= DATA.new():import(file or the.train) 
  print(l.fmt("%.3f",d:chebyshevs().mu))
  d:tree():visit() end
-- ---------------------------------------------------------------------------------------
-- ## Start-up
if   pcall(debug.getlocal, 4, 1) 
then return {DATA=DATA,NUM=NUM,SYM=SYM,BIN=BIN,TREE=TREE,the=the,lib=l,eg=eg,help=help}
else the = l.settings(help)
     math.randomseed(the.seed or 1234567891)
     for k,v in pairs(arg) do if eg[v] then eg[v](l.coerce(arg[k+1])) end end end

-- <!-- ③   ④   ⑤    ⑥   ⑦   ⑧    ⑨  ①  ②  -->
